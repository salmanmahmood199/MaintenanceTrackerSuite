1. Add the billing flag to your Neon Postgres
You can run a one-off SQL migration against your Neon instance. From your terminal:

bash
Copy
Edit
# export your connection string
export DATABASE_URL="postgresql://neondb_owner:npg_IFlB1kzgai8c@ep-flat-glitter-adty96yu.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require"

# run the ALTER TABLE
psql "$DATABASE_URL" <<SQL
ALTER TABLE users
  ADD COLUMN can_view_billing BOOLEAN NOT NULL DEFAULT FALSE;
SQL
This will add a new boolean column (defaulting to false) to every user.

2. Wire your .env and Drizzle config
Create or update a .env file in your project root:

ini
Copy
Edit
# .env
DATABASE_URL="postgresql://neondb_owner:npg_IFlB1kzgai8c@ep-flat-glitter-adty96yu.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require"
Install dotenv if you haven’t already:

bash
Copy
Edit
npm install dotenv
Update drizzle.config.ts (or wherever you initialize Drizzle) to load from process.env.DATABASE_URL:

ts
Copy
Edit
import "dotenv/config";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

// pull in your new column in the table definition:
import { pgTable, serial, varchar, boolean, ... } from "drizzle-orm/pg-core";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  email: varchar("email", { length: 256 }).notNull(),
  // … your existing columns …
  can_view_billing: boolean("can_view_billing").notNull().default(false),
});

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  // any other Neon-specific options…
});

export const db = drizzle(pool);
3. Update your shared Zod/TypeScript schemas
In your shared schema file (e.g. shared/schemas.ts), add the new flag:

ts
Copy
Edit
import { z } from "zod";

export const UserSchema = z.object({
  id: z.number(),
  email: z.string().email(),
  // … other fields …
  canViewBilling: z.boolean().default(false),
});
export type User = z.infer<typeof UserSchema>;
If you’re mapping snake_case to camelCase, ensure your serialization layer (or Drizzle mappers) converts can_view_billing → canViewBilling.

4. Accept canViewBilling in your “Add Sub-Admin” route
In server/routes.ts (or wherever you handle POST /api/users for new sub-admins):

Extend your request body schema:

ts
Copy
Edit
import { z } from "zod";

export const SubAdminCreateSchema = z.object({
  firstName: z.string(),
  lastName: z.string(),
  email: z.string().email(),
  password: z.string(),
  permissions: z.object({
    canPlaceTicket: z.boolean(),
    canAcceptTicket: z.boolean(),
    canViewBilling: z.boolean().default(false),
  }),
});
Parse and persist the new flag:

ts
Copy
Edit
import { SubAdminCreateSchema } from "./schemas";
import { requireRole } from "./middleware/auth";

router.post(
  "/api/users",
  requireAuth,
  requireRole("org_admin"),
  asyncHandler(async (req, res) => {
    const { firstName, lastName, email, password, permissions } = SubAdminCreateSchema.parse(req.body);

    const user = await storage.createUser({
      firstName,
      lastName,
      email,
      password,
      roles: ["org_subadmin"],
      flags: {
        placeTicket: permissions.canPlaceTicket,
        acceptTicket: permissions.canAcceptTicket,
        viewBilling: permissions.canViewBilling,
      },
    });

    res.status(201).json(user);
  })
);
Make sure your storage.createUser writes can_view_billing into the DB.

5. Add the “View Billing” checkbox in your Add-Sub-Admin form
In your front-end modal (e.g. client/src/components/AddSubAdmin.tsx):

tsx
Copy
Edit
// … inside your form …
<Checkbox
  id="canViewBilling"
  checked={form.values.permissions.canViewBilling}
  onChange={() =>
    form.setFieldValue(
      "permissions.canViewBilling",
      !form.values.permissions.canViewBilling
    )
  }
>
  View Billing
</Checkbox>
And when you call your API, include that flag in the JSON payload.

6. Create a billing-guard middleware
In server/middleware/permissions.ts:

ts
Copy
Edit
export function requireViewBilling(req: Request, res: Response, next: NextFunction) {
  if (!req.user?.canViewBilling) {
    return res.status(403).json({ error: "Forbidden: billing access required" });
  }
  next();
}
7. Expose a filtered invoices endpoint
In server/routes.ts:

ts
Copy
Edit
import { requireViewBilling } from "./middleware/permissions";

router.get(
  "/api/invoices",
  requireAuth,
  requireViewBilling,
  asyncHandler(async (req, res) => {
    const orgId = req.user.organizationId;
    const locationIds = req.user.visibleLocationIds; // however you track this

    const invoices = await storage.getInvoicesForOrg({ orgId, locationIds });
    res.json(invoices);
  })
);
And in storage.ts:

ts
Copy
Edit
export async function getInvoicesForOrg(opts: {
  orgId: number;
  locationIds: number[];
}) {
  return db
    .select({ invoice: invoices, ticket: tickets })
    .from(invoices)
    .innerJoin(tickets, eq(tickets.id, invoices.ticketId))
    .where(
      and(
        eq(tickets.orgId, opts.orgId),
        inArray(tickets.locationId, opts.locationIds)
      )
    );
}
8. Surface a “Billing” tab in the UI
In your dashboard page (e.g. client/src/pages/Dashboard.tsx):

tsx
Copy
Edit
const baseTabs = ["Tickets", "Sub-Admins", "Locations", "Vendors"];
const tabs = currentUser.canViewBilling ? [...baseTabs, "Billing"] : baseTabs;

// render your Tab headers …
<Tabs activeTab={tab} onChange={setTab}>
  {tabs.map(label => (
    <Tab key={label} label={label} />
  ))}
</Tabs>

// …and conditionally show the billing pane:
{tab === "Billing" && <InvoiceTable />}
<InvoiceTable /> should fetch("/api/invoices") and render invoice#, ticket#, amount, status, date, etc.

9. Verify end-to-end
Create two sub-admins—one with “View Billing,” one without.

Log in as each:

The user without billing should not see the tab and get a 403 on /api/invoices.

The user with billing sees the tab and only invoices for their org & locations.